/*
동적계획법(Dynamic Programming)
DP, Bottom Up 방식으로 풀어보자.

삼각형의 각 노드는 그 아래의 두 노드 중 하나로만 이동할 수 있다.
즉, 각 노드의 최적 해를 계산하기 위해서는 그 아래의 노드들에서 최적 해를 먼저 알고 있어야 한다.

현재 노드의 최적 해는 아래 노드들의 최적 해에 의존한다.
Bottom-Up 방식은 이 구조에 잘 맞아떨어진다.
즉, 바닥에서 시작하여 위로 올라가면서 각 위치의 최적 해를 계산하므로 자연스럽게 의존성을 처리할 수 있다.

Top-Down 방식에서는 재귀 호출을 사용하여 하위 문제를 해결하고, 메모이제이션을 통해 중복 계산을 방지한다.
재귀 호출은 스택을 사용하므로, 깊은 재귀 호출로 인해 스택 오버플로우가 발생할 수 있다.
특히 삼각형의 높이가 클 때 문제가 될 수 있다.
메모이제이션을 사용하는 경우에도, 각 위치에서 중복된 하위 문제를 계산할 수 있어 최악의 경우 비효율적일 수 있다.

Bottom-Up 방식에서는 반복문을 사용하여 DP 배열을 직접 채우므로 스택 오버플로우의 위험이 없다.
메모리 사용은 Top-Down 방식과 유사하지만, 반복문을 통해 모든 문제를 한 번씩만 계산하므로 효율적이다.

시간 복잡도: O(n^2)
공간 복잡도: O(n^2)
*/

function solution(triangle) {
  const height = triangle.length;
  
  // DP 배열을 삼각형과 같은 구조로 초기화한다.
  let dp = triangle[height - 1];
  
  // Bottom-Up 방식으로 DP 배열을 갱신한다.
  for (let i = height - 2; i >= 0; i--) {
      for (let j = 0; j < triangle[i].length; j++) {
          // 현재 위치에서 가능한 두 하위 위치의 최대 값을 더하여 현재 위치를 갱신한다.
          dp[j] = triangle[i][j] + Math.max(dp[j], dp[j + 1]);
      }
  }
  
  // 최상단 위치 (0, 0)에서의 최대 합을 리턴
  return dp[0];
}

//console.log(solution([[7], [3, 8]])) //15
console.log(solution([[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]])) //30