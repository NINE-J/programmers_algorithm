/*
문제 설명
효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는
(1칸, 1칸, 1칸, 1칸)
(1칸, 2칸, 1칸)
(1칸, 1칸, 2칸)
(2칸, 1칸, 1칸)
(2칸, 2칸)
의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.

제한 사항
n은 1 이상, 2000 이하인 정수입니다.
입출력 예
n	result
4	5
3	3
입출력 예 설명
입출력 예 #1
위에서 설명한 내용과 같습니다.

입출력 예 #2
(2칸, 1칸)
(1칸, 2칸)
(1칸, 1칸, 1칸)
총 3가지 방법으로 멀리 뛸 수 있습니다.
*/
function solution(n) {
  /*
  경우의 수는 피보나치 수열로 표현할 수 있다.
  1 = 1 [1]
  2 = 2 [11,2]
  3 = 3 [111,12,21]
  4 = 5 [1111,112,121,211,22]
  5 = 8 [11111,1112,1121,1211,2111,122,221,212]
  6 = 13 [111111,11112,11121,11211,12111,21111,1122,2211,1221,2112,1212,2121,222]
  ...
  일단은 무식하게 접근했지만,
  직접 점화식을 세워볼 때 피보나치 수열의 점화식과 같아진다고 보는 게 낫다.
  *점화식: 어떤 수열의 각각의 항들의 관계를 나타낸 식

  한 번의 이동에 1칸 또는 2칸을 이동할 수 있다.
  현재 n칸째의 경우의 수를 구한다면 n-1칸에서 1칸 뛰어서 온경우, n-2칸에서 2칸 뛰어서 온 경우 외에는 존재하지 않는다.

  따라서 dp[n] = dp[n-1] + dp[n-2]라는 점화식이 세워진다.
  */
  //n이 1인 경우 수열 공식 적용 못 함. 경우의 수는 1이므로 리턴
  if(n===1) return 1

  //피보나치 수열의 n번째를 구하기 위한 공식
  let answer = 0
  let arr = []
  arr[0] = 1
  arr[1] = 1
  for(let i=2; i <= n; i++) {
      //주어진 문제에서 n의 최대값은 2000이고 2000까지의 수열을 계산하다보면 오버플로가 발생한다.
      //원소를 계산할 때 미리 주어진 조건대로 나머지를 저장한 뒤 구하는 n번째의 원소를 리턴한다.
      arr[i] = (arr[i-1]+arr[i-2])%1234567
  }

  answer = arr[arr.length-1]

  return answer
}